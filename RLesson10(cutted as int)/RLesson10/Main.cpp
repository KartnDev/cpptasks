#include <iostream>
#include <conio.h>
#include <string>

using namespace std;

// реализация односвязного списка(как в STL)
class List
{
public:
	List(); // конструктор с вынесеным телом (реализацией)
	~List(); // деструктор ---||---

						//		МЕТОДЫ
	void push_back(int data); // метод добавления элемента назад (листа)
	void push_front(int data); // метод добавления элемента в начало(головную часть)
	void insert(int data, int index); // метод добавления по индексу в список
	void pop_back(); // метод удаления последнего элемента (последнего)
	void pop_front(); // метод удаления головного элемента(первого)
	void remove_at(int index); // удаление элемента по индексу в списке
	void clear(); // полное удаления списка
	int getsize() { return SIZE; } //геттер(получатель) размера списка



	// перегружаем оператор [] 
	// для того, чтобы можно было получать элементы с помощью оператора [] 
	// реализация находится в main.cpp
	int& operator[](const int index);

private:
	// класс (вложеный) нода (узел)
	// нода - примитив списка (его объект), то из чего состоит сам список
	// класс шаблонный, чтобы была возможность хранить любой тип данных 
	// typename?????????
	class Node
	{
	public:
		Node *p_next;
		int data;

		//		КОНСТРУКТОР НОДЫ: 
		// при передачи в конструктор ноды мы должны по дефолту обозначитьь их(во избежание мусора)
		// так указатель на след. ноду будет иметь нулл-ссылку
		// передаваемый тип данных (дата) будет по дефолту :
		// если класс то вызван конструктор по умолчанияю
		// если же примитивный тип данных, то присвоено дефолтное значение примитивного типа
		// все это делается во избежания мусора(ненужных неправильных данных) в неуказаных полях
		Node(int data = 0, Node *p_next = nullptr)
		{
			this->data = data;
			this->p_next = p_next;
		}
	};
	int SIZE; // длина списка
	Node *head; // головной член списка
};

// опередление конструктора
// при создании экземпляра все внутренние поля должны будут 
// определены дефолтными(стандартными для типа) значениями

List::List()
{
	SIZE = 0;
	head = nullptr;
}



// при конце работы списка (вызове деструктора) 
// список должен будет быть стёрт
List::~List()
{
	clear();
}



// тело метода показа в консоль всех данных в списке
// в каррент запишем ссылку на головную ноду
// сразу выведем данные из каррент ноды
// после чего в цикле будем в каррент будем передавать
// ссылку на следеющую ноду
// получится что каждый раз вы будем попадать в следующую ноду 
// будучи в переменной каррент
// и сразу выводить данные из ноды




// тело метода добавления в конец списка 
// 
void List::push_back(int data)
{
	if (head == nullptr)
	{
		head = new Node(data);
	}
	else
	{
		Node *current = this->head;

		while (current -> p_next != nullptr)
		{
			current = current-> p_next;
		}
		current->p_next = new Node(data);
	}
	SIZE++;
}

void List::push_front(int data)
{
	head = new Node(data, head);
	SIZE++;
}


// метод внесения элемента на индексированное место
// 

void List::insert(int data, int index)
{
	if (index == 0)
	{
		push_front(data);
	}
	else
	{
		Node* p_prev = this->head;

		for (int i = 0; i < index - 1; i++)
		{
			p_prev = p_prev->p_next;
		}

		Node* new_node = new Node(data, p_prev->p_next);

		p_prev->p_next = new_node;

		SIZE++;
	}
}

void List::pop_back()
{
	remove_at(SIZE - 1);
}

void List::pop_front()
{	 //переносим головную ноду на следующую ноду, а данную(бывшую головную) 
	 //записываем в временную переменную temp 
	Node *temp = head;
	head = head->p_next;
	delete temp;
	SIZE--;
}
// метод отчистки элемента по индексу
// если 1 элемент то просто сотрем последний элемент
// листаемся по списку
// если доходим до элементаа, который лежит перед тем,
// который надо удалить
// то связывем его с элементом, корый лежит после удаляемого
// связывем эти эелементы i-1 и i+1 
// удаляем индексированный элемент

void List::remove_at(int index)
{
	if (index == 0)
	{
		pop_front();
	}
	else
	{
		Node* p_prev = this->head;
		for (int i = 0; i < index - 1; i++)
		{
			p_prev = p_prev->p_next;
		}

		Node* p_removed = p_prev -> p_next;

		p_prev->p_next = p_removed -> p_next;

		delete p_removed;
		SIZE--;
	}


}




// метод полной отчистки памяти от списка
// суть в том, чтобы вызвать функция стирания первого элемента
// при высове метода поп_фронт удаляется элемент(нода) (головной)
// там после уменьшения SIZE--  
// тогда можем сделать выражение явного приведения от целогочисленного до булева
// любое ненулевое число == True 
// 0 == False 

void List::clear()
{
	while ((bool)SIZE) // size > 0
	{
		pop_front();
	}

}


// реализация перегрузки оператора	[]
// смысл реализации: передается константное число и записываем счетчик(каунтер)
// создается нода(узел) которая является ссылкой на головную часть списка
// потом в цикле мы записываем в созданную ноду ссылку на следующую ноду
// если получается так, что каунтер будет равен переданному константному числу
// мы нашли тот самый индексированный элемент
// возвращаем его
// возвращается ссылка, чтобы было возможно воздействовать на данные находящиеся по индексу
int& List::operator[](const int index)
{
	int counter = 0;
	Node *p_current = this->head;

	while(p_current != nullptr)
	{
		if (counter == index)
		{
			return p_current -> data;
		}
		p_current = p_current->p_next;

		counter++;
	}
	
}

void display_data(List &list)
{
	for (int i = 0; i < list.getsize(); i++)
	{
		cout << "Элемент [" << i << "] = " << list[i] << endl;
	}
}

int main()
{
	setlocale(LC_ALL, "ru");

	List list;

	list.push_back(5);
	list.push_front(7);
	list.push_back(100);
	display_data(list);
	cout << "Добавим 77 на 2ий индекс\n";
	list.insert(77, 2);
	display_data(list);
	cout << "Данные в 2 элементе : " << list[2] << "\n";
	cout << "Данные в 0 элементе : " << list[0] << "\n";
	cout << "Изменим 0 элемента на другие: \n";
	list[0] = 1324;
	cout << "Данные в 0 элементе : " << list[0] << "\n";
	display_data(list);
	list.pop_front();
	cout << "удаление переднего элемента\n";
	display_data(list);
	cout << "удаление 1ого элемента\n";
	list.remove_at(1);
	display_data(list);
	cout << "удаление последнего элемента\n";
	list.pop_back();
	display_data(list);
	_getch(); // Серьезность	Код	Описание	Проект	Файл	Строка	Состояние подавления Предупреждение	C6031	Возвращаемое значение пропущено : "_getch".RLesson10	
		

	return EXIT_SUCCESS;
}
// бинарное упорядоченое дерево